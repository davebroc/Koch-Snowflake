import java.awt.Color;
import java.awt.Graphics;
import javax.swing.JPanel;
import java.awt.*;
import java.awt.geom.Line2D;
import java.util.HashMap;
import java.awt.event.*;

/**
 * A JPanel that draws a Koch snowflake fractal.
 * The fractal is generated by applying a recursive production rule to an
 * initial axiom string, and
 * then interpreting the resulting string as a series of graphics commands to
 * draw lines.
 * This is using L-System notation.
 * 
 * The class allows the user to zoom in and out using the mouse wheel, and the
 * fractal will be redrawn
 * with the updated scale. The fractal is drawn in black lines on a white
 * background.
 * 
 * @author David Brockbank
 * @version 1.0, March 2023
 */
public class KochSnowflake extends JPanel implements MouseWheelListener {
    /**
     * The axiom of the Koch snowflake fractal. This L-system rule represents the
     * starting equilateral
     * triangle.
     */
    private static String axiom = "F++F++F";

    /**
     * The L-system rule used to add a triangle in the middle of a line.
     */
    private static String productionRule = "F-F++F-F";

    /**
     * The order of the Koch snowflake fractal.
     */
    private int order = 1;

    /**
     * The x-coordinate of the starting point of the fractal.
     */
    private int startX = 683;

    /**
     * The y-coordinate of the starting point of the fractal.
     */
    private int startY = 600;

    /**
     * Factor altering the scale of the drawing. This mimics a zoom action.
     */
    private double zoomFactor = 1000;

    /**
     * The scaling constant used to adjust the zoom factor to a smaller scale.
     */
    private final double scaleZoomFactor = 0.00000004;

    /**
     * The maximum level out "zooming out" allowed. Depends on the current size
     * of the JFrame that contains the Koch snowflake fractal.
     */
    private int maxZoomFactor = (int) zoomFactor;

    /**
     * The starting length of the Koch snowflake fractal. Must be a power of 3
     * greater than the maximum order allowed.
     */
    private final int startLength = 14348907; // 3^15

    /**
     * A HashMap that stores the lines of the Koch snowflake fractal for reuse.
     */
    private HashMap<String, Line2D> lines = new HashMap<String, Line2D>();

    /**
     * KochSnowflake Constructor.
     * Adds the mouseListener to the class
     */
    public KochSnowflake() {
        addMouseWheelListener(this);
    }

    /**
     * Sets the order of the Koch snowflake fractal.
     * 
     * @param newOrder the new order of the fractal
     */
    public void setOrder(int newOrder) {
        order = newOrder;
    }

    /**
     * Resizes the Koch snowflake fractal based on the width, height, and scale
     * provided.
     * 
     * @param width  the width of the JFrame that contains the fractal
     * @param height the height of the JFrame that contains the fractal
     * @param scale  the scale of the JFrame that contains the fractal
     */
    public void resize(int width, int height, int scale) {
        zoomFactor = scale;
        maxZoomFactor = scale;
        startX = (width / 2) - (int) (startLength * zoomFactor * scaleZoomFactor / 2);
        startY = (height / 2) - (int) (Math.tan(Math.PI / 6) * (startLength * zoomFactor * scaleZoomFactor / 2));
    }

    /**
     * Recursively draws the Koch snowflake fractal using a string representation of
     * the fractal, an angle, a length, and an order.
     * 
     * @param g      the Graphics2D object used to draw the fractal
     * @param angle  the angle at which the fractal is drawn
     * @param str    the string representation of the fractal
     * @param length the length of the fractal
     * @param ord    the order of the fractal
     */
    private void drawSnowflake(Graphics2D g, int angle, String str, int length, int ord) {
        if (angle < 360 || angle > -360)
            angle = angle % 360;

        if (angle == 360)// same angle
            angle = 0;
        if (angle == -180)// direction irrelevant
            angle = 180;

        for (char c : str.toCharArray()) {
            switch (c) {
                case 'F':
                    if (ord > 1) {
                        drawSnowflake(g, angle, productionRule, length / 3, ord - 1);
                        break;
                    }

                    Line2D line;
                    String key = angle + "," + length;
                    if (!lines.containsKey(key)) {
                        double newX = length * Math.cos(Math.toRadians(angle));
                        double newY = length * Math.sin(Math.toRadians(angle));
                        line = new Line2D.Double(0, 0, newX, newY);
                        lines.put(key, line);
                    } else
                        line = lines.get(key);

                    g.draw(line);
                    g.translate(line.getX2(), line.getY2());

                    break;
                case '+':
                    angle += 60;
                    break;
                case '-':
                    angle -= 60;
                    break;

                default:
                    break;
            }

        }
    }

    /**
     * Function to scale the snowflake to mimic zooming in and out.
     * 
     * @param e The MouseWheelEvent generated by the mouse wheel movement.
     */
    public void mouseWheelMoved(MouseWheelEvent e) {
        if (e.getWheelRotation() < 0)// zoom in
            zoomFactor *= 1.1;
        else // zoom out
            zoomFactor /= 1.1;

        if (zoomFactor < maxZoomFactor)
            zoomFactor = maxZoomFactor;

        repaint();
    }

    /**
     * Paints the component.
     * 
     * @param g the Graphics2D object used to draw the fractal
     */
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        Graphics2D g2 = (Graphics2D) g.create();
        g2.setStroke(new BasicStroke(3));
        g2.setColor(new Color(0, 0, 0));
        g2.translate(startX, startY);
        g2.scale(scaleZoomFactor * zoomFactor, scaleZoomFactor * zoomFactor);

        drawSnowflake(g2, 0, axiom, startLength, order);
    }

}
